{{!--
  Product Listing Page (PLP)
  Based on design template: plp.html
--}}
<div class="relative flex h-auto min-h-screen w-full flex-col">
  <div class="flex flex-1">
  {{> filters-sidebar filters=filters activeFilters=activeFilters searchTerm=searchTerm category=category}}

  <!-- Products Grid -->
  <main class="flex-1 p-8">
    <div class="flex flex-col gap-6">
      <!-- Header Bar -->
      <div class="flex items-center justify-between">
        {{> breadcrumbs items=breadcrumbs}}
        <div class="flex items-center gap-4">
          <div class="flex items-center gap-2">
            <label class="text-sm text-gray-600 dark:text-gray-400" for="sort-by">Sort by:</label>
            <select
              class="form-select text-sm font-medium bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-600 rounded-lg focus:ring-primary focus:border-primary p-2"
              id="sort-by"
              onchange="handleSortChange(this.value)">
              <option value="best-match" {{#ifEquals sortBy "best-match"}}selected{{/ifEquals}}>Best Match</option>
              <option value="price-low" {{#ifEquals sortBy "price-low"}}selected{{/ifEquals}}>Price: Low to High</option>
              <option value="price-high" {{#ifEquals sortBy "price-high"}}selected{{/ifEquals}}>Price: High to Low</option>
              <option value="name" {{#ifEquals sortBy "name"}}selected{{/ifEquals}}>Product Name</option>
            </select>
          </div>
          <div class="flex items-center border border-gray-300 dark:border-gray-600 rounded-lg p-1">
            <button
              id="view-grid-btn"
              class="p-1.5 rounded-md {{#ifEquals viewMode "grid"}}bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200{{else}}text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800{{/ifEquals}} transition-colors"
              onclick="setViewMode('grid')"
              title="Grid View">
              <span class="material-symbols-outlined !text-xl">grid_view</span>
            </button>
            <button
              id="view-list-btn"
              class="p-1.5 rounded-md {{#ifEquals viewMode "list"}}bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200{{else}}text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800{{/ifEquals}} transition-colors"
              onclick="setViewMode('list')"
              title="List View">
              <span class="material-symbols-outlined !text-xl">view_list</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Product Cards/List -->
      <div id="product-container">
        {{#ifEquals viewMode "list"}}
          {{> product-list products=products showCheckbox=true}}
        {{else}}
          {{> product-grid products=products}}
        {{/ifEquals}}
      </div>

      <!-- Pagination -->
      {{#if pagination}}
        <div class="flex items-center justify-between pt-4 border-t border-gray-200 dark:border-gray-700">
          <p class="text-sm text-gray-600 dark:text-gray-400">
            Showing <span class="font-medium">{{pagination.start}}</span>
            to <span class="font-medium">{{pagination.end}}</span>
            of <span class="font-medium">{{pagination.total}}</span> results
          </p>
          <nav class="flex items-center gap-2">
            <button
              class="flex items-center justify-center h-9 w-9 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700"
              {{#unless pagination.hasPrevious}}disabled{{/unless}}
              onclick="goToPage({{math pagination.page '-' 1}})">
              <span class="material-symbols-outlined !text-xl">chevron_left</span>
            </button>
            {{#each pagination.pages}}
              <button
                class="flex items-center justify-center h-9 w-9 rounded-lg border {{#ifEquals this ../pagination.page}}border-primary bg-primary/20 text-primary{{else}}border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700{{/ifEquals}}"
                onclick="goToPage({{this}})">
                {{this}}
              </button>
            {{/each}}
            <button
              class="flex items-center justify-center h-9 w-9 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700"
              {{#unless pagination.hasNext}}disabled{{/unless}}
              onclick="goToPage({{math pagination.page '+' 1}})">
              <span class="material-symbols-outlined !text-xl">chevron_right</span>
            </button>
          </nav>
        </div>
      {{/if}}
    </div>
  </main>
  </div>
</div>

{{!-- Variant Selection Modal --}}
{{> variant-selection-modal}}

<script>
// Define addToCart immediately so it's available for onclick handlers
window.addToCart = async function(productId, quantity) {
  console.log('addToCart called with:', { productId, quantity });
  const qty = parseInt(quantity) || 1;

  if (isNaN(qty) || qty < 1) {
    alert('Please enter a valid quantity.');
    return;
  }

  // Ensure productDataCache exists
  window.productDataCache = window.productDataCache || {};

  // Check if product has variants by checking data attribute
  const productCard = document.querySelector(`[data-product-id="${productId}"]`)?.closest('.flex.flex-col, .bg-white');
  let hasVariants = productCard?.dataset?.hasVariants === 'true';
  console.log('Variant check:', { productId, hasVariants, dataset: productCard?.dataset });

  // If we don't have the data attribute, check cache first
  if (hasVariants === undefined || hasVariants === false) {
    if (window.productDataCache && window.productDataCache[productId]) {
      hasVariants = window.productDataCache[productId].hasVariants ||
                   (window.productDataCache[productId].variants && window.productDataCache[productId].variants.length > 0);
      console.log('Variant check from cache:', { hasVariants, cached: window.productDataCache[productId] });
    }
  }

  // If product has variants, show modal instead of adding directly
  if (hasVariants === true) {
    console.log('Product has variants, showing modal');
    try {
      // Wait a bit to ensure showVariantModal is defined
      if (typeof window.showVariantModal === 'function') {
        await window.showVariantModal(productId, qty);
      } else {
        console.error('showVariantModal function not found, waiting...');
        // Wait for function to be available
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if (typeof window.showVariantModal === 'function') {
              clearInterval(checkInterval);
              resolve(window.showVariantModal(productId, qty));
            }
          }, 100);
          setTimeout(() => {
            clearInterval(checkInterval);
            if (typeof window.showVariantModal !== 'function') {
              console.error('showVariantModal still not available after 2 seconds');
              alert('Variant selection is not available. Please refresh the page.');
            }
            resolve();
          }, 2000);
        });
      }
    } catch (error) {
      console.error('Error showing variant modal:', error);
      alert('Failed to open variant selection. Please try again.');
    }
    return;
  }

  console.log('Product has no variants, proceeding with direct add to cart');

  // Find and disable all "Add to Cart" buttons for this product
  const buttons = document.querySelectorAll(`button[data-product-id="${productId}"]`);
  console.log('Found buttons:', buttons.length);

  if (buttons.length === 0) {
    console.error('No add to cart buttons found for product:', productId);
    alert('Unable to find add to cart button. Please refresh the page.');
    return;
  }

  const originalTexts = [];
  buttons.forEach((btn, index) => {
    originalTexts[index] = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span>Adding...</span>';
    btn.classList.add('opacity-50', 'cursor-not-allowed');
  });

  console.log('Sending add to cart request...');
  fetch('/api/cart/items', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include', // Include session cookies for authentication
    body: JSON.stringify({
      productId: productId,
      quantity: qty,
    }),
  })
    .then(response => {
      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }
      if (!response.ok) {
        return response.json().then(err => {
          throw new Error(err.message || 'Failed to add to cart');
        });
      }
      return response.json();
    })
    .then(data => {
      console.log('Add to cart response:', data);

      // Calculate total items from the response
      // Use itemCount (number of unique products) or items.length as fallback
      let totalItems = 0;
      if (data) {
        if (data.itemCount !== undefined && data.itemCount !== null) {
          totalItems = data.itemCount;
        } else if (data.items && Array.isArray(data.items)) {
          totalItems = data.items.length;
        }
      }

      console.log('Total items from add to cart response:', totalItems);

      // Update badge directly with the response data
      const badge = document.getElementById('cart-count-badge');
      if (badge && totalItems > 0) {
        badge.textContent = totalItems > 99 ? '99+' : totalItems.toString();
        badge.setAttribute('style',
          'display: flex !important; ' +
          'visibility: visible !important; ' +
          'opacity: 1 !important; ' +
          'position: absolute !important; ' +
          'top: -4px !important; ' +
          'right: -4px !important; ' +
          'z-index: 9999 !important; ' +
          'background-color: #ef4444 !important; ' +
          'color: #ffffff !important; ' +
          'border-radius: 9999px !important; ' +
          'min-width: 20px !important; ' +
          'height: 20px !important; ' +
          'padding: 0 6px !important; ' +
          'font-size: 12px !important; ' +
          'font-weight: bold !important; ' +
          'align-items: center !important; ' +
          'justify-content: center !important; ' +
          'box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;'
        );
        badge.classList.remove('hidden');

        // Animate the badge
        badge.classList.add('animate-bounce');
        setTimeout(() => {
          badge.classList.remove('animate-bounce');
        }, 1000);
      } else if (badge) {
        console.warn('Badge found but totalItems is 0 or badge not found');
      } else {
        console.error('Cart badge element not found after adding to cart');
      }

      // Also update via the global function as backup, passing the count directly
      if (typeof window.updateCartCount === 'function') {
        // Use itemCount (number of unique products) or items.length as fallback
        const totalItems = data.itemCount !== undefined ? data.itemCount : (data.items?.length || 0);
        window.updateCartCount(totalItems);
      }

      // Re-enable buttons
      buttons.forEach((btn, index) => {
        btn.disabled = false;
        btn.innerHTML = originalTexts[index];
        btn.classList.remove('opacity-50', 'cursor-not-allowed');
      });
    })
    .catch(error => {
      console.error('Error adding to cart:', error);

      // Re-enable buttons on error
      buttons.forEach((btn, index) => {
        btn.disabled = false;
        btn.innerHTML = originalTexts[index];
        btn.classList.remove('opacity-50', 'cursor-not-allowed');
      });

      const message = document.createElement('div');
      message.className = 'fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-50';
      message.textContent = error.message || 'Failed to add product to cart';
      document.body.appendChild(message);

      setTimeout(() => {
        message.remove();
      }, 3000);
    });
};

(function() {
  'use strict';

  // Debounce function
  function debounce(func, wait) {
    let timeout;
    return function executedFunction() {
      const args = arguments;
      const context = this;
      const later = function() {
        clearTimeout(timeout);
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Initialize view mode from URL params first, then localStorage
  function getViewModeFromUrl() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('viewMode') || localStorage.getItem('productViewMode') || 'grid';
  }

  let currentViewMode = getViewModeFromUrl();

  // Update currentViewMode from URL on page load
  currentViewMode = getViewModeFromUrl();

  // Update view mode buttons state
  function updateViewModeButtons() {
    const gridBtn = document.getElementById('view-grid-btn');
    const listBtn = document.getElementById('view-list-btn');

    if (gridBtn && listBtn) {
      if (currentViewMode === 'grid') {
        gridBtn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        gridBtn.classList.remove('text-gray-500', 'dark:text-gray-400');
        listBtn.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        listBtn.classList.add('text-gray-500', 'dark:text-gray-400');
      } else {
        listBtn.classList.add('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        listBtn.classList.remove('text-gray-500', 'dark:text-gray-400');
        gridBtn.classList.remove('bg-gray-200', 'dark:bg-gray-700', 'text-gray-800', 'dark:text-gray-200');
        gridBtn.classList.add('text-gray-500', 'dark:text-gray-400');
      }
    }
  }

  // Set view mode and reload with query param
  window.setViewMode = function(mode) {
    currentViewMode = mode;
    localStorage.setItem('productViewMode', mode);
    const url = new URL(window.location);
    url.searchParams.set('viewMode', mode);
    // Preserve all other params (filters, search, sortBy)
    // Don't remove page param - keep current page
    window.location.href = url.toString();
  };

  // Handle sort change
  window.handleSortChange = function(value) {
    const url = new URL(window.location);
    url.searchParams.set('sortBy', value);
    // Reset to page 1 when sorting changes
    url.searchParams.set('page', '1');
    window.location.href = url.toString();
  };

  // Go to page
  window.goToPage = function(page) {
    const url = new URL(window.location);
    url.searchParams.set('page', page);
    window.location.href = url.toString();
  };

  // Apply filters - preserves all selected filters and viewMode
  window.applyFilters = function() {
    const form = document.querySelector('aside');
    if (!form) {
      console.error('Filters sidebar not found');
      return;
    }

    const params = new URLSearchParams();

    // Get search input value
    const searchInput = form.querySelector('input[type="text"], input[name="search"], input[type="search"]');
    if (searchInput && searchInput.value && searchInput.value.trim()) {
      params.set('search', searchInput.value.trim());
    }

    // Get all checked checkboxes - collect multiple values per filter name
    const filterValues = {};
    const checkboxes = form.querySelectorAll('input[type="checkbox"]:checked');

    checkboxes.forEach(function(checkbox) {
      const name = checkbox.name;
      const value = checkbox.value;

      if (name && value) {
        if (!filterValues[name]) {
          filterValues[name] = [];
        }
        filterValues[name].push(value);
      }
    });

    // Add all filter values to params (each value gets its own param)
    Object.keys(filterValues).forEach(function(filterName) {
      filterValues[filterName].forEach(function(value) {
        params.append(filterName, value);
      });
    });

    // Reset to page 1 when applying filters
    params.set('page', '1');

    // Preserve sortBy if exists
    const currentSortBy = new URL(window.location).searchParams.get('sortBy');
    if (currentSortBy) {
      params.set('sortBy', currentSortBy);
    }

    // Preserve viewMode (important!) - get from URL or current state
    const urlParams = new URLSearchParams(window.location.search);
    const savedViewMode = urlParams.get('viewMode') || currentViewMode || 'grid';
    params.set('viewMode', savedViewMode);

    window.location.href = '/products?' + params.toString();
  };

  // Clear filters
  window.clearFilters = function() {
    const url = new URL('/products', window.location.origin);

    // Preserve viewMode
    if (currentViewMode) {
      url.searchParams.set('viewMode', currentViewMode);
    }

    window.location.href = url.toString();
  };

  // Debounced search function - only reloads after user stops typing
  let searchTimeout = null;

  const performSearch = debounce(function(searchTerm) {
    const url = new URL(window.location);

    if (searchTerm && searchTerm.trim()) {
      url.searchParams.set('search', searchTerm.trim());
    } else {
      url.searchParams.delete('search');
    }

    // Reset to page 1 when searching
    url.searchParams.set('page', '1');

    // Preserve other filters
    const form = document.querySelector('aside');
    if (form) {
      // First, clear existing filter params
      url.searchParams.delete('categoryId');
      url.searchParams.delete('brand');
      url.searchParams.delete('isActive');

      // Then add checked checkboxes
      const checkboxes = form.querySelectorAll('input[type="checkbox"]:checked');
      checkboxes.forEach(function(checkbox) {
        const name = checkbox.name;
        const value = checkbox.value;

        if (name && value) {
          url.searchParams.append(name, value);
        }
      });
    }

    // Preserve sortBy
    const currentSortBy = new URL(window.location).searchParams.get('sortBy');
    if (currentSortBy) {
      url.searchParams.set('sortBy', currentSortBy);
    }

    // Preserve viewMode
    if (currentViewMode) {
      url.searchParams.set('viewMode', currentViewMode);
    }

    window.location.href = url.toString();
  }, 800); // 800ms debounce delay - longer to avoid interrupting typing

  // Setup debounced search for any search input (sidebar or navbar)
  function setupDebouncedSearch(searchInput, preserveFilters) {
    if (!searchInput) return;

    // Set current search value from URL
    const urlParams = new URLSearchParams(window.location.search);
    const currentSearch = urlParams.get('search');
    if (currentSearch) {
      searchInput.value = currentSearch;
    }

    let localSearchTimeout = null;

    // Add input event listener - don't reload while typing
    searchInput.addEventListener('input', function(e) {
      const target = e.target;
      const searchTerm = target.value;

      // Clear any pending search
      if (localSearchTimeout) {
        clearTimeout(localSearchTimeout);
      }
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }

      // Only trigger search after user stops typing for 800ms
      localSearchTimeout = window.setTimeout(function() {
        if (preserveFilters) {
          performSearch(searchTerm);
        } else {
          // For navbar, just redirect to products page with search
          const url = new URL('/products', window.location.origin);
          if (searchTerm && searchTerm.trim()) {
            url.searchParams.set('search', searchTerm.trim());
          }
          // Preserve viewMode
          const currentViewModeFromUrl = getViewModeFromUrl();
          url.searchParams.set('viewMode', currentViewModeFromUrl);
          window.location.href = url.toString();
        }
      }, 800);
      searchTimeout = localSearchTimeout;
    });

    // Handle Enter key - search immediately
    searchInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        if (localSearchTimeout) {
          clearTimeout(localSearchTimeout);
        }
        if (searchTimeout) {
          clearTimeout(searchTimeout);
        }
        const target = e.target;
        const searchTerm = target.value;
        if (preserveFilters) {
          performSearch(searchTerm);
        } else {
          // For navbar, just redirect to products page with search
          const url = new URL('/products', window.location.origin);
          if (searchTerm && searchTerm.trim()) {
            url.searchParams.set('search', searchTerm.trim());
          }
          // Preserve viewMode
          const currentViewModeFromUrl = getViewModeFromUrl();
          url.searchParams.set('viewMode', currentViewModeFromUrl);
          window.location.href = url.toString();
        }
      }
    });
  }

  // Setup search input listeners on page load
  document.addEventListener('DOMContentLoaded', function() {
    // Update currentViewMode from URL first (before anything else)
    currentViewMode = getViewModeFromUrl();
    // Save to localStorage for next time
    if (currentViewMode) {
      localStorage.setItem('productViewMode', currentViewMode);
    }

    // Initialize view mode buttons first
    updateViewModeButtons();

    // Setup sidebar search (preserves filters)
    const sidebarSearchInput = document.querySelector('aside input[type="text"], aside input[name="search"], aside input[type="search"]');
    if (sidebarSearchInput) {
      setupDebouncedSearch(sidebarSearchInput, true);
      // Restore checkbox states from URL
      restoreCheckboxStates();
    }

    // Setup navbar search (doesn't preserve filters - starts fresh)
    const navbarSearchInput = document.getElementById('navbar-search');
    if (navbarSearchInput) {
      setupDebouncedSearch(navbarSearchInput, false);
    }
  });

  // Restore checkbox states from URL parameters
  function restoreCheckboxStates() {
    const urlParams = new URLSearchParams(window.location.search);
    const form = document.querySelector('aside');

    if (form) {
      // Get all filter values from URL
      const categoryIds = urlParams.getAll('categoryId');
      const brands = urlParams.getAll('brand');
      const isActive = urlParams.get('isActive');

      // Restore category checkboxes
      categoryIds.forEach(function(categoryId) {
        const checkbox = form.querySelector('input[type="checkbox"][name="categoryId"][value="' + categoryId + '"]');
        if (checkbox) {
          checkbox.checked = true;
        }
      });

      // Restore brand checkboxes
      brands.forEach(function(brand) {
        const checkbox = form.querySelector('input[type="checkbox"][name="brand"][value="' + brand + '"]');
        if (checkbox) {
          checkbox.checked = true;
        }
      });

      // Restore isActive checkbox
      if (isActive) {
        const checkbox = form.querySelector('input[type="checkbox"][name="isActive"][value="' + isActive + '"]');
        if (checkbox) {
          checkbox.checked = true;
        }
      }
    }
  }

  // Store product data for variant modal
  window.productDataCache = window.productDataCache || {};
})();

  // Variant Selection Modal Functions
  window.showVariantModal = async function(productId, defaultQuantity = 1) {
    console.log('showVariantModal called with:', { productId, defaultQuantity });

    const modal = document.getElementById('variant-modal');
    const modalContent = document.getElementById('variant-modal-content');
    const productName = document.getElementById('variant-modal-name');
    const productPrice = document.getElementById('variant-modal-price');
    const productImage = document.getElementById('variant-modal-image');
    const quantityInput = document.getElementById('variant-modal-quantity');
    const addToCartBtn = document.getElementById('variant-modal-add-to-cart-btn');

    console.log('Modal elements found:', {
      modal: !!modal,
      modalContent: !!modalContent,
      productName: !!productName,
      productPrice: !!productPrice,
      productImage: !!productImage,
      quantityInput: !!quantityInput,
      addToCartBtn: !!addToCartBtn,
    });

    if (!modal) {
      console.error('Modal element not found! Make sure variant-selection-modal partial is included.');
      alert('Modal not found. Please refresh the page.');
      return;
    }

    // Set default quantity
    if (quantityInput) {
      quantityInput.value = defaultQuantity;
    }

    // Show loading state with cancel button and progress indicator
    if (modalContent) {
      modalContent.innerHTML = `
        <div class="text-center py-8">
          <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-primary mb-4"></div>
          <div class="text-slate-500 dark:text-slate-400 mb-2">Loading variants...</div>
          <p class="text-xs text-slate-400 dark:text-slate-500 mb-4">This may take a few seconds</p>
          <button
            onclick="if(typeof window.closeVariantModal === 'function') window.closeVariantModal();"
            class="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600">
            Cancel
          </button>
        </div>
      `;
    }
    if (addToCartBtn) {
      addToCartBtn.disabled = true;
    }

    // Open modal by checking the checkbox (CSS peer selector will handle visibility)
    console.log('Opening modal by checking checkbox...');
    modal.checked = true;

    // Trigger change event to ensure CSS peer classes update
    modal.dispatchEvent(new Event('change', { bubbles: true }));

    // Also manually ensure visibility (fallback if CSS doesn't work immediately)
    setTimeout(() => {
      const modalContainer = document.querySelector('.fixed.bottom-0.z-50');
      const backdrop = document.querySelector('label[for="variant-modal"]');

      if (modalContainer) {
        console.log('Modal container found, ensuring visibility');
        modalContainer.style.transform = 'translateY(0)';
        modalContainer.style.display = 'flex';
        modalContainer.style.visibility = 'visible';
        modalContainer.style.opacity = '1';
      } else {
        console.warn('Modal container not found - checking if modal partial is rendered');
        // Check if modal exists in DOM
        const checkModal = document.getElementById('variant-modal');
        if (!checkModal) {
          console.error('Modal checkbox not in DOM! Partial may not be included.');
        }
      }

      if (backdrop) {
        backdrop.style.display = 'block';
        backdrop.style.visibility = 'visible';
        backdrop.style.opacity = '1';
      }
    }, 50);

    // Check cache first
    let productData = window.productDataCache[productId];

    // Fetch product details if not in cache
    if (!productData) {
      // Store abort controller so we can cancel if user closes modal
      window.currentFetchController = new AbortController();
      const controller = window.currentFetchController;

      try {
        console.log('Fetching product details from API...', productId);

        // Add timeout to prevent hanging (reduced to 15 seconds - if it takes longer, something is wrong)
        const timeoutId = setTimeout(() => {
          console.error('Request timeout after 15 seconds');
          controller.abort();
        }, 15000);

        const fetchPromise = fetch(`/api/products/${productId}?format=json`, {
          credentials: 'include',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          },
          signal: controller.signal,
        }).finally(() => {
          clearTimeout(timeoutId);
          window.currentFetchController = null;
        });

        const response = await fetchPromise;

        if (!response.ok) {
          let errorText = '';
          try {
            errorText = await response.text();
          } catch (e) {
            errorText = 'Could not read error response';
          }
          console.error('Failed to fetch product:', {
            status: response.status,
            statusText: response.statusText,
            body: errorText,
            productId: productId,
          });

          if (response.status === 401) {
            throw new Error('Authentication required. Please log in and try again.');
          } else if (response.status === 404) {
            throw new Error('Product not found. It may have been removed.');
          } else {
            throw new Error(`Failed to fetch product details: ${response.status} ${response.statusText}`);
          }
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const text = await response.text();
          console.error('Expected JSON but got:', contentType, text.substring(0, 200));
          throw new Error('Server returned non-JSON response');
        }

        productData = await response.json();
        console.log('Product data received:', productData);
        console.log('Product variants:', productData.variants);
        console.log('Has variants:', productData.hasVariants, 'Variants length:', productData.variants?.length);

        if (!productData || !productData.id) {
          console.error('Invalid product data received:', productData);
          throw new Error('Invalid product data received from server');
        }

        // Check if product actually has variants
        if (!productData.variants || productData.variants.length === 0) {
          console.warn('Product has no variants, but was flagged as having variants. Adding directly to cart instead.');
          // Close modal and add directly to cart
          if (modal) {
            modal.checked = false;
          }
          // Call addToCart directly without variant
          window.addToCart(productId, defaultQuantity);
          return;
        }

        window.productDataCache[productId] = productData;
      } catch (error) {
        console.error('Error fetching product:', error);

        // Don't show error if request was cancelled by user
        if (error.name === 'AbortError' && !error.message?.includes('timeout')) {
          console.log('Request was cancelled by user');
          return;
        }

        // Check if it's an abort error (timeout)
        const isTimeout = error.name === 'AbortError' || error.message?.includes('timeout');
        const errorMessage = isTimeout
          ? 'Request timed out after 15 seconds. The server may be slow or unavailable. Please try again.'
          : (error.message || 'Failed to load product details. Please try again.');

        // Show error in modal instead of alert
        if (modalContent) {
          modalContent.innerHTML = `
            <div class="text-center py-8">
              <div class="text-red-600 dark:text-red-400 mb-4">
                <span class="material-symbols-outlined text-4xl">error</span>
              </div>
              <p class="text-lg font-semibold text-slate-900 dark:text-slate-50 mb-2">Failed to load product details</p>
              <p class="text-sm text-slate-600 dark:text-slate-400 mb-4">${errorMessage}</p>
              <div class="flex gap-2 justify-center">
                <button
                  onclick="if(typeof window.showVariantModal === 'function') window.showVariantModal('${productId}', ${defaultQuantity});"
                  class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90">
                  Retry
                </button>
                <button
                  onclick="if(typeof window.closeVariantModal === 'function') window.closeVariantModal();"
                  class="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600">
                  Close
                </button>
              </div>
            </div>
          `;
        }

        if (addToCartBtn) {
          addToCartBtn.disabled = true;
        }

        // Don't return - allow user to close modal or retry
        return;
      }
    }

    // Populate product info
    if (productName) productName.textContent = productData.name;
    if (productPrice) {
      const priceRange = productData.priceRange;
      if (priceRange) {
        productPrice.textContent = `$${priceRange.min.toFixed(2)} - $${priceRange.max.toFixed(2)}`;
      } else {
        productPrice.textContent = `$${productData.basePrice.toFixed(2)}`;
      }
    }
    if (productImage && productData.primaryImage) {
      productImage.style.backgroundImage = `url('${productData.primaryImage.url}')`;
      productImage.setAttribute('data-alt', productData.primaryImage.altText || productData.name);
    } else if (productImage && productData.images && productData.images.length > 0) {
      productImage.style.backgroundImage = `url('${productData.images[0].url}')`;
      productImage.setAttribute('data-alt', productData.name);
    }

    // Populate variants
    console.log('Populating variants in modal...', {
      modalContent: !!modalContent,
      variants: productData.variants,
      variantsLength: productData.variants?.length,
    });

    if (modalContent && productData.variants && productData.variants.length > 0) {
      console.log('Rendering', productData.variants.length, 'variants');
      let variantsHtml = '<div class="flex flex-col gap-3">';
      variantsHtml += '<label class="text-sm font-semibold text-slate-700 dark:text-slate-300">Select Configuration:</label>';
      variantsHtml += '<div class="grid grid-cols-1 gap-2">';

      productData.variants.forEach((variant, index) => {
        console.log('Processing variant', index, variant);

        // Calculate variant price
        // Note: calculateFinalPrice is a method on ProductVariantDto, but when serialized to JSON it's not available
        // So we calculate it manually using priceDelta
        let variantPrice = productData.basePrice || 0;
        if (variant.priceDelta !== undefined && variant.priceDelta !== null) {
          variantPrice = (productData.basePrice || 0) + (variant.priceDelta || 0);
        } else if (variant.price !== undefined) {
          variantPrice = variant.price;
        }
        console.log('Variant price calculated:', variantPrice);

        const isActive = variant.isActive !== false;
        const isFirst = index === 0;
        const firstActive = productData.variants.findIndex(v => v.isActive !== false);

        // Escape HTML in variant data to prevent XSS
        const safeSku = (variant.sku || 'N/A').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        const safeVariantId = (variant.id || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');

        // Build attributes HTML safely
        let attributesHtml = '';
        if (variant.attributes && typeof variant.attributes === 'object') {
          attributesHtml = Object.entries(variant.attributes)
            .map(([key, value]) => {
              const safeKey = String(key).replace(/</g, '&lt;').replace(/>/g, '&gt;');
              const safeValue = String(value).replace(/</g, '&lt;').replace(/>/g, '&gt;');
              return `<span class="px-2 py-1 rounded bg-slate-100 dark:bg-slate-800">
                <span class="font-medium capitalize">${safeKey}:</span> ${safeValue}
              </span>`;
            })
            .join('');
        }

        variantsHtml += `
          <label class="variant-option cursor-pointer relative flex items-center justify-between p-4 border-2 ${isActive ? 'border-slate-200 dark:border-slate-700 hover:border-primary dark:hover:border-primary' : 'border-slate-300 dark:border-slate-600 opacity-50'} rounded-lg transition-colors"
            data-variant-id="${safeVariantId}"
            data-variant-price="${variantPrice}"
            data-variant-available="${isActive}">
            <input type="radio"
              name="variant-selection"
              value="${safeVariantId}"
              class="sr-only variant-radio"
              ${!isActive ? 'disabled' : ''}
              ${(isFirst && isActive) || (firstActive === index) ? 'checked' : ''}
              onchange="if(typeof window.selectVariant === 'function') window.selectVariant('${safeVariantId}', ${variantPrice})">
            <div class="flex-1">
              <div class="flex items-center gap-2 mb-1">
                <span class="text-sm font-medium text-slate-800 dark:text-white">${safeSku}</span>
                ${isActive
                  ? `<span class="text-xs px-2 py-0.5 rounded-full bg-green-100 dark:bg-green-900/50 text-green-700 dark:text-green-300">In Stock${variant.availableQuantity ? ` (${variant.availableQuantity})` : ''}</span>`
                  : '<span class="text-xs px-2 py-0.5 rounded-full bg-red-100 dark:bg-red-900/50 text-red-700 dark:text-red-300">Out of Stock</span>'
                }
              </div>
              <div class="flex flex-wrap gap-2 text-xs text-slate-600 dark:text-slate-400">
                ${attributesHtml}
              </div>
            </div>
            <div class="ml-4 text-right">
              <div class="text-lg font-bold text-slate-800 dark:text-white">
                $${variantPrice.toFixed(2)}
              </div>
            </div>
          </label>
        `;
      });

      variantsHtml += '</div></div>';

      console.log('Setting variants HTML in modal content, HTML length:', variantsHtml.length);
      try {
        modalContent.innerHTML = variantsHtml;
        console.log('Variants HTML set successfully');

        // Enable add to cart button
        if (addToCartBtn) {
          addToCartBtn.disabled = false;
          console.log('Add to cart button enabled');
        }

        // Initialize first active variant selection
        const firstActiveVariant = productData.variants.find(v => v.isActive !== false) || productData.variants[0];
        if (firstActiveVariant) {
          console.log('Selecting first active variant:', firstActiveVariant.id);
          let firstVariantPrice = productData.basePrice;
          if (firstActiveVariant.calculateFinalPrice && typeof firstActiveVariant.calculateFinalPrice === 'function') {
            firstVariantPrice = firstActiveVariant.calculateFinalPrice(productData.basePrice);
          } else if (firstActiveVariant.priceDelta !== undefined) {
            firstVariantPrice = productData.basePrice + firstActiveVariant.priceDelta;
          } else if (firstActiveVariant.price !== undefined) {
            firstVariantPrice = firstActiveVariant.price;
          }
          if (typeof window.selectVariant === 'function') {
            window.selectVariant(firstActiveVariant.id, firstVariantPrice);
          } else {
            console.error('selectVariant function not found');
          }
        }
      } catch (error) {
        console.error('Error setting variants HTML:', error);
        if (modalContent) {
          modalContent.innerHTML = `
            <div class="text-center py-8">
              <p class="text-red-600 dark:text-red-400 mb-4">Error rendering variants: ${error.message}</p>
              <button
                onclick="if(typeof window.closeVariantModal === 'function') window.closeVariantModal();"
                class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90">
                Close
              </button>
            </div>
          `;
        }
      }
    } else {
      console.warn('No variants to display', {
        modalContent: !!modalContent,
        variants: productData.variants,
        variantsLength: productData.variants?.length,
      });
      if (modalContent) {
        modalContent.innerHTML = `
          <div class="text-center py-8">
            <p class="text-slate-500 dark:text-slate-400 mb-4">No variants available for this product.</p>
            <button
              onclick="if(typeof window.closeVariantModal === 'function') window.closeVariantModal();"
              class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90">
              Close
            </button>
          </div>
        `;
      }
      if (addToCartBtn) {
        addToCartBtn.disabled = true;
      }
    }

    // Set min/max quantity
    if (quantityInput) {
      quantityInput.min = productData.minOrderQuantity || 1;
      quantityInput.max = productData.maxOrderQuantity || '';
    }

    // Store product data for add to cart
    window.currentProductForModal = productData;

    // Ensure modal is open and visible after data is loaded
    console.log('Finalizing modal display with product data...');
    if (modal) {
      modal.checked = true;
      modal.dispatchEvent(new Event('change', { bubbles: true }));

      // Force visibility after data is loaded
      setTimeout(() => {
        const modalContainer = document.querySelector('.fixed.bottom-0.z-50');
        const backdrop = document.querySelector('label[for="variant-modal"]');

        console.log('Checking modal visibility:', {
          modalChecked: modal.checked,
          modalContainer: !!modalContainer,
          backdrop: !!backdrop,
        });

        if (modalContainer) {
          console.log('Modal container found, ensuring visibility');
          // Remove any conflicting classes and force visibility
          modalContainer.classList.remove('translate-y-full');
          modalContainer.classList.add('translate-y-0');
          modalContainer.style.transform = 'translateY(0)';
          modalContainer.style.display = 'flex';
          modalContainer.style.visibility = 'visible';
          modalContainer.style.opacity = '1';
          modalContainer.style.zIndex = '50';
        } else {
          console.error('Modal container not found after loading data');
          console.log('Available elements with variant-modal:', {
            checkbox: !!document.getElementById('variant-modal'),
            content: !!document.getElementById('variant-modal-content'),
            allFixed: document.querySelectorAll('.fixed').length,
          });
        }

        if (backdrop) {
          backdrop.style.display = 'block';
          backdrop.style.visibility = 'visible';
          backdrop.style.opacity = '1';
          backdrop.style.zIndex = '40';
        }
      }, 100);
    } else {
      console.error('Modal checkbox not found when trying to finalize');
    }
  }

  // Close variant modal
  window.closeVariantModal = function() {
    console.log('Closing variant modal...');

    // Cancel any pending fetch request
    if (window.currentFetchController) {
      console.log('Cancelling pending fetch request');
      window.currentFetchController.abort();
      window.currentFetchController = null;
    }

    const modal = document.getElementById('variant-modal');
    if (modal) {
      modal.checked = false;
      modal.dispatchEvent(new Event('change', { bubbles: true }));

      // Hide modal container
      setTimeout(() => {
        const modalContainer = document.querySelector('.fixed.bottom-0.z-50');
        const backdrop = document.querySelector('label[for="variant-modal"]');

        if (modalContainer) {
          modalContainer.style.transform = 'translateY(100%)';
          modalContainer.style.display = 'none';
        }

        if (backdrop) {
          backdrop.style.display = 'none';
        }
      }, 50);
    }
  };

  // Select variant in modal
  window.selectVariant = function(variantId, variantPrice) {
    window.selectedVariantId = variantId;
    window.selectedVariantPrice = variantPrice;

    // Update radio button visual state
    document.querySelectorAll('.variant-option').forEach(option => {
      const radio = option.querySelector('.variant-radio');
      if (radio && radio.value === variantId) {
        option.classList.add('border-primary', 'bg-primary/5');
        option.classList.remove('border-slate-200', 'border-slate-700');
      } else {
        option.classList.remove('border-primary', 'bg-primary/5');
        option.classList.add('border-slate-200', 'dark:border-slate-700');
      }
    });

    // Enable add to cart button if variant is available
    const addToCartBtn = document.getElementById('variant-modal-add-to-cart-btn');
    const variantOption = document.querySelector(`[data-variant-id="${variantId}"]`);
    const isAvailable = variantOption?.dataset.variantAvailable === 'true';

    if (addToCartBtn) {
      addToCartBtn.disabled = !isAvailable || !variantId;
    }
  };

  // Quantity controls for modal
  window.increaseVariantQuantity = function() {
    const input = document.getElementById('variant-modal-quantity');
    const max = input?.getAttribute('max');
    if (input) {
      let value = parseInt(input.value) || 1;
      if (!max || value < parseInt(max)) {
        input.value = value + 1;
        validateVariantQuantity();
      }
    }
  };

  window.decreaseVariantQuantity = function() {
    const input = document.getElementById('variant-modal-quantity');
    const min = parseInt(input?.getAttribute('min') || '1');
    if (input) {
      let value = parseInt(input.value) || 1;
      if (value > min) {
        input.value = value - 1;
        validateVariantQuantity();
      }
    }
  };

  window.validateVariantQuantity = function() {
    const input = document.getElementById('variant-modal-quantity');
    const min = parseInt(input?.getAttribute('min') || '1');
    const max = input?.getAttribute('max');
    if (input) {
      let value = parseInt(input.value) || min;
      if (value < min) value = min;
      if (max && value > parseInt(max)) value = parseInt(max);
      input.value = value;
    }
  };

  // Add to cart from modal
  window.addToCartFromModal = async function() {
    const productId = window.currentProductForModal?.id;
    const variantId = window.selectedVariantId;
    const quantityInput = document.getElementById('variant-modal-quantity');
    const addToCartBtn = document.getElementById('variant-modal-add-to-cart-btn');
    const modal = document.getElementById('variant-modal');

    if (!productId || !variantId) {
      alert('Please select a variant');
      return;
    }

    const qty = parseInt(quantityInput?.value || '1');
    if (isNaN(qty) || qty < 1) {
      alert('Please enter a valid quantity');
      return;
    }

    // Disable button
    if (addToCartBtn) {
      addToCartBtn.disabled = true;
      addToCartBtn.innerHTML = '<span class="truncate">Adding...</span>';
    }

    try {
      const response = await fetch('/api/cart/items', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          productId: productId,
          variantId: variantId,
          quantity: qty,
        }),
      });

      if (response.status === 401) {
        window.location.href = '/login';
        return;
      }

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to add to cart');
      }

      const data = await response.json();
      console.log('Add to cart response:', data);

      // Update cart count
      const totalItems = data.itemCount !== undefined ? data.itemCount : (data.items?.length || 0);
      if (typeof window.updateCartCount === 'function') {
        window.updateCartCount(totalItems);
      }

      // Close modal
      if (modal) {
        modal.checked = false;
        modal.dispatchEvent(new Event('change', { bubbles: true }));
      }

      // Hide modal container
      setTimeout(() => {
        const modalContainer = document.querySelector('.fixed.bottom-0.z-50');
        const backdrop = document.querySelector('label[for="variant-modal"]');

        if (modalContainer) {
          modalContainer.style.transform = 'translateY(100%)';
          modalContainer.style.display = 'none';
        }

        if (backdrop) {
          backdrop.style.display = 'none';
        }
      }, 50);
    } catch (error) {
      console.error('Error adding to cart:', error);
      alert(error.message || 'Failed to add item to cart. Please try again.');
    } finally {
      // Re-enable button
      if (addToCartBtn) {
        addToCartBtn.disabled = false;
        addToCartBtn.innerHTML = '<span class="truncate">Add to Cart</span>';
      }
    }
  };
</script>

